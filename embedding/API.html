<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Documentation &mdash; megaman 0.3.dev0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.3.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="megaman 0.3.dev0 documentation" href="../index.html" />
    <link rel="up" title="Tools for Embedding (megaman.embedding)" href="index.html" />
    <link rel="next" title="Utility tools for megaman (megaman.utils)" href="../utils/index.html" />
    <link rel="prev" title="Spectral Embedding" href="spectral_embedding.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="embedding-api"></span><div class="section" id="module-megaman.embedding.spectral_embedding">
<span id="api-documentation"></span><h1>API Documentation<a class="headerlink" href="#module-megaman.embedding.spectral_embedding" title="Permalink to this headline">¶</a></h1>
<p>Spectral Embedding</p>
<dl class="class">
<dt id="megaman.embedding.spectral_embedding.SpectralEmbedding">
<em class="property">class </em><code class="descclassname">megaman.embedding.spectral_embedding.</code><code class="descname">SpectralEmbedding</code><span class="sig-paren">(</span><em>n_components=2</em>, <em>eigen_solver='auto'</em>, <em>random_state=None</em>, <em>eigen_tol=1e-12</em>, <em>drop_first=True</em>, <em>diffusion_maps=False</em>, <em>geom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/spectral_embedding.html#SpectralEmbedding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.spectral_embedding.SpectralEmbedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral embedding for non-linear dimensionality reduction.</p>
<p>Forms an affinity matrix given by the specified function and
applies spectral decomposition to the corresponding graph laplacian.
The resulting transformation is given by the value of the
eigenvectors for each data point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_components</strong> : integer, optional</p>
<blockquote>
<div><p>The dimension of the projection subspace.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>random_state</strong> : int seed, RandomState instance, or None (default)</p>
<blockquote>
<div><p>A pseudo random number generator used for the initialization of the
lobpcg eigen vectors decomposition when eigen_solver == &#8216;amg&#8217;.
By default, arpack is used.</p>
</div></blockquote>
<p><strong>eigen_tol</strong> : float, optional, default=0.0</p>
<blockquote>
<div><p>Stopping criterion for eigendecomposition of the Laplacian matrix
when using arpack eigen_solver.</p>
</div></blockquote>
<p><strong>drop_first</strong> : bool, optional, default=True</p>
<blockquote>
<div><p>Whether to drop the first eigenvector. For spectral embedding, this
should be True as the first eigenvector should be constant vector for
connected graph, but for spectral clustering, this should be kept as
False to retain the first eigenvector.</p>
</div></blockquote>
<p><strong>diffusion_map</strong> : boolean, optional. Whether to return the diffusion map</p>
<blockquote>
<div><p>version by re-scaling the embedding by the eigenvalues.</p>
</div></blockquote>
<p><strong>neighborhood_radius</strong> : scalar, passed to distance_matrix. Value such that all</p>
<blockquote>
<div><p>distances beyond neighborhood_radius are considered infinite.</p>
</div></blockquote>
<p><strong>affinity_radius</strong> : scalar, passed to affinity matrix, bandwidth parameter</p>
<blockquote>
<div><p>used in Guassian kernel for affinity matrix</p>
</div></blockquote>
<p><strong>distance_method</strong> : string, one of &#8216;auto&#8217;, &#8216;brute&#8217;, &#8216;cython&#8217;, &#8216;pyflann&#8217;, &#8216;cyflann&#8217;.</p>
<blockquote>
<div><p>method for computing pairwise radius neighbors graph.</p>
</div></blockquote>
<p><strong>input_type</strong> : string, one of: &#8216;data&#8217;, &#8216;distance&#8217;, &#8216;affinity&#8217;.</p>
<blockquote>
<div><p>The values of input data X.</p>
</div></blockquote>
<p><strong>path_to_flann</strong> : string. full file path location of FLANN if not installed to</p>
<blockquote>
<div><p>root or to set FLANN_ROOT set to path location. Used for importing pyflann
from a different location.</p>
</div></blockquote>
<p><strong>geom</strong> : either a Geometry object from megaman.geometry or a dictionary</p>
<blockquote class="last">
<div><p>containing (some or all) geometry parameters: adjacency_method,
adjacency_kwds, affinity_method, affinity_kwds, laplacian_method,
laplacian_kwds as keys.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>A Tutorial on Spectral Clustering, 2007
Ulrike von Luxburg
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</a></li>
<li>On Spectral Clustering: Analysis and an algorithm, 2011
Andrew Y. Ng, Michael I. Jordan, Yair Weiss
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100</a></li>
<li>Normalized cuts and image segmentation, 2000
Jianbo Shi, Jitendra Malik
<a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</a></li>
</ul>
<dl class="method">
<dt id="megaman.embedding.spectral_embedding.SpectralEmbedding.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>input_type='data'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/spectral_embedding.html#SpectralEmbedding.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.spectral_embedding.SpectralEmbedding.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model from data in X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input_type</strong> : string, one of: &#8216;data&#8217;, &#8216;distance&#8217; or &#8216;affinity&#8217;.</p>
<blockquote>
<div><p>The values of input data X. (default = &#8216;data&#8217;)</p>
</div></blockquote>
<p><strong>X</strong> : array-like, shape (n_samples, n_features)</p>
<blockquote>
<div><p>Training vector, where n_samples in the number of samples
and n_features is the number of features.</p>
</div></blockquote>
<p><strong>If self.input_type is distance, or affinity:</strong></p>
<p><strong>X</strong> : array-like, shape (n_samples, n_samples),</p>
<blockquote>
<div><p>Interpret X as precomputed distance or adjacency graph
computed from samples.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : object</p>
<blockquote class="last">
<div><p>Returns the instance itself.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="megaman.embedding.spectral_embedding.spectral_embedding">
<code class="descclassname">megaman.embedding.spectral_embedding.</code><code class="descname">spectral_embedding</code><span class="sig-paren">(</span><em>geom</em>, <em>n_components=8</em>, <em>eigen_solver='auto'</em>, <em>random_state=None</em>, <em>eigen_tol=0.0</em>, <em>drop_first=True</em>, <em>diffusion_maps=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/spectral_embedding.html#spectral_embedding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.spectral_embedding.spectral_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the sample on the first eigen vectors of the graph Laplacian.</p>
<p>The adjacency matrix is used to compute a normalized graph Laplacian
whose spectrum (especially the eigen vectors associated to the
smallest eigen values) has an interpretation in terms of minimal
number of cuts necessary to split the graph into comparably sized
components.</p>
<p>This embedding can also &#8216;work&#8217; even if the <code class="docutils literal"><span class="pre">adjacency</span></code> variable is
not strictly the adjacency matrix of a graph but more generally
an affinity or similarity matrix between samples (for instance the
heat kernel of a euclidean distance matrix or a k-NN matrix).</p>
<p>However care must taken to always make the affinity matrix symmetric
so that the eigen vector decomposition works as expected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>geom</strong> : a Geometry object from megaman.embedding.geometry</p>
<p><strong>n_components</strong> : integer, optional</p>
<blockquote>
<div><p>The dimension of the projection subspace.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>random_state</strong> : int seed, RandomState instance, or None (default)</p>
<blockquote>
<div><p>A pseudo random number generator used for the initialization of the
lobpcg eigen vectors decomposition when eigen_solver == &#8216;amg&#8217;.
By default, arpack is used.</p>
</div></blockquote>
<p><strong>eigen_tol</strong> : float, optional, default=0.0</p>
<blockquote>
<div><p>Stopping criterion for eigendecomposition of the Laplacian matrix
when using arpack eigen_solver.</p>
</div></blockquote>
<p><strong>drop_first</strong> : bool, optional, default=True</p>
<blockquote>
<div><p>Whether to drop the first eigenvector. For spectral embedding, this
should be True as the first eigenvector should be constant vector for
connected graph, but for spectral clustering, this should be kept as
False to retain the first eigenvector.</p>
</div></blockquote>
<p><strong>diffusion_map</strong> : boolean, optional. Whether to return the diffusion map</p>
<blockquote>
<div><p>version by re-scaling the embedding by the eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>embedding</strong> : array, shape=(n_samples, n_components)</p>
<blockquote class="last">
<div><p>The reduced samples.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Spectral embedding is most useful when the graph has one connected
component. If there graph has many components, the first few eigenvectors
will simply uncover the connected components of the graph.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/LOBPCG">http://en.wikipedia.org/wiki/LOBPCG</a></li>
<li>Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method
Andrew V. Knyazev
<a class="reference external" href="http://dx.doi.org/10.1137%2FS1064827500366124">http://dx.doi.org/10.1137%2FS1064827500366124</a></li>
</ul>
</dd></dl>

<span class="target" id="module-megaman.embedding.isomap"></span><p>ISOMAP</p>
<dl class="class">
<dt id="megaman.embedding.isomap.Isomap">
<em class="property">class </em><code class="descclassname">megaman.embedding.isomap.</code><code class="descname">Isomap</code><span class="sig-paren">(</span><em>n_components=2</em>, <em>eigen_solver='auto'</em>, <em>random_state=None</em>, <em>eigen_tol=1e-12</em>, <em>path_method='auto'</em>, <em>geom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/isomap.html#Isomap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.isomap.Isomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Isomap Embedding</p>
<p>Non-linear dimensionality reduction through Isometric Mapping</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_components</strong> : integer, default: 2</p>
<blockquote>
<div><p>The dimension of the projected subspace.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>random_state</strong> : int seed, RandomState instance, or None, default</p>
<blockquote>
<div><p>A pseudo random number generator used for the initialization of the
lobpcg eigen vectors decomposition when eigen_solver == &#8216;amg&#8217;.</p>
</div></blockquote>
<p><strong>eigen_tol</strong> : float, optional. Tolerance for &#8216;arpack&#8217; solver.</p>
<p><strong>path_method</strong> : string, optionl. method for computing graph shortest path.</p>
<blockquote>
<div><p>One of :
&#8216;auto&#8217;, &#8216;D&#8217;, &#8216;FW&#8217;, &#8216;BF&#8217;, &#8216;J&#8217;. See scipy.sparse.csgraph.shortest_path
for more information.</p>
</div></blockquote>
<p><strong>geom</strong> : either a Geometry object from megaman.geometry or a dictionary</p>
<blockquote>
<div><p>containing (some or all) geometry parameters: adjacency_method,
adjacency_kwds, affinity_method, affinity_kwds, laplacian_method,
laplacian_kwds as keys.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>embedding_</strong> : array, shape = (n_samples, n_components)</p>
<blockquote class="last">
<div><p>Spectral embedding of the training matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R1]</a></td><td>Tenenbaum, J.B.; De Silva, V.; &amp; Langford, J.C. A global geometric
framework for nonlinear dimensionality reduction. Science 290 (5500)</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="megaman.embedding.isomap.Isomap.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>input_type='data'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/isomap.html#Isomap.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.isomap.Isomap.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model from data in X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input_type</strong> : string, one of: &#8216;data&#8217;, &#8216;distance&#8217;.</p>
<blockquote>
<div><p>The values of input data X. (default = &#8216;data&#8217;)</p>
</div></blockquote>
<p><strong>X</strong> : array-like, shape (n_samples, n_features)</p>
<blockquote>
<div><p>Training vector, where n_samples in the number of samples
and n_features is the number of features.</p>
</div></blockquote>
<p><strong>If self.input_type is &#8216;distance&#8217;:</strong></p>
<p><strong>X</strong> : array-like, shape (n_samples, n_samples),</p>
<blockquote>
<div><p>Interpret X as precomputed distance or adjacency graph
computed from samples.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {None, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><p>The eigenvalue decomposition strategy to use. AMG requires pyamg
to be installed. It can be faster on very large, sparse problems,
but may also lead to instabilities.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : object</p>
<blockquote class="last">
<div><p>Returns the instance itself.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="megaman.embedding.isomap.isomap">
<code class="descclassname">megaman.embedding.isomap.</code><code class="descname">isomap</code><span class="sig-paren">(</span><em>geom</em>, <em>n_components=8</em>, <em>eigen_solver='auto'</em>, <em>random_state=None</em>, <em>eigen_tol=1e-12</em>, <em>path_method='auto'</em>, <em>distance_matrix=None</em>, <em>graph_distance_matrix=None</em>, <em>centered_matrix=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/isomap.html#isomap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.isomap.isomap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>geom</strong> : a Geometry object from megaman.geometry.geometry</p>
<p><strong>n_components</strong> : integer, optional</p>
<blockquote>
<div><p>The dimension of the projection subspace.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>random_state</strong> : int seed, RandomState instance, or None (default)</p>
<blockquote>
<div><p>A pseudo random number generator used for the initialization of the
lobpcg eigen vectors decomposition when eigen_solver == &#8216;amg&#8217;.
By default, arpack is used.</p>
</div></blockquote>
<p><strong>eigen_tol</strong> : float, optional, default=0.0</p>
<blockquote>
<div><p>Stopping criterion for eigendecomposition of the Laplacian matrix
when using arpack eigen_solver.</p>
</div></blockquote>
<p><strong>path_method</strong> : string, method for computing graph shortest path. One of :</p>
<blockquote>
<div><p>&#8216;auto&#8217;, &#8216;D&#8217;, &#8216;FW&#8217;, &#8216;BF&#8217;, &#8216;J&#8217;. See scipy.sparse.csgraph.shortest_path
for more information.</p>
</div></blockquote>
<p><strong>distance_matrix</strong> : sparse Ndarray (n_obs, n_obs), optional. Pairwise distance matrix</p>
<blockquote>
<div><p>sparse zeros considered &#8216;infinite&#8217;.</p>
</div></blockquote>
<p><strong>graph_distance_matrix</strong> : Ndarray (n_obs, n_obs), optional. Pairwise graph distance</p>
<blockquote>
<div><p>matrix. Output of graph_shortest_path.</p>
</div></blockquote>
<p><strong>centered_matrix</strong> : Ndarray (n_obs, n_obs), optional. Centered version of</p>
<blockquote>
<div><p>graph_distance_matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>embedding</strong> : array, shape=(n_samples, n_components)</p>
<blockquote class="last">
<div><p>The reduced samples.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-megaman.embedding.locally_linear"></span><p>Locally Linear Embedding</p>
<dl class="class">
<dt id="megaman.embedding.locally_linear.LocallyLinearEmbedding">
<em class="property">class </em><code class="descclassname">megaman.embedding.locally_linear.</code><code class="descname">LocallyLinearEmbedding</code><span class="sig-paren">(</span><em>n_components=2</em>, <em>eigen_solver='auto'</em>, <em>random_state=None</em>, <em>tol=1e-06</em>, <em>max_iter=100</em>, <em>reg=1000.0</em>, <em>geom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/locally_linear.html#LocallyLinearEmbedding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.locally_linear.LocallyLinearEmbedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Locally Linear Embedding</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_components</strong> : integer</p>
<blockquote>
<div><p>number of coordinates for the manifold.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>tol</strong> : float, optional</p>
<blockquote>
<div><p>Tolerance for &#8216;arpack&#8217; method
Not used if eigen_solver==&#8217;dense&#8217;.</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>maximum number of iterations for the arpack solver.</p>
</div></blockquote>
<p><strong>random_state</strong> : numpy.RandomState or int, optional</p>
<blockquote>
<div><p>The generator or seed used to determine the starting vector for arpack
iterations.  Defaults to numpy.random.</p>
</div></blockquote>
<p><strong>reg</strong> : float</p>
<blockquote>
<div><p>regularization constant, multiplies the trace of the local covariance
matrix of the distances.</p>
</div></blockquote>
<p><strong>geom</strong> : either a Geometry object from megaman.geometry or a dictionary</p>
<blockquote class="last">
<div><p>containing (some or all) geometry parameters: adjacency_method,
adjacency_kwds, affinity_method, affinity_kwds, laplacian_method,
laplacian_kwds as keys.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Roweis, S. &amp; Saul, L. Nonlinear dimensionality reduction
by locally linear embedding.  Science 290:2323 (2000).</li>
</ul>
<dl class="method">
<dt id="megaman.embedding.locally_linear.LocallyLinearEmbedding.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>input_type='data'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/locally_linear.html#LocallyLinearEmbedding.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.locally_linear.LocallyLinearEmbedding.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model from data in X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input_type</strong> : string, one of: &#8216;data&#8217;, &#8216;distance&#8217;.</p>
<blockquote>
<div><p>The values of input data X. (default = &#8216;data&#8217;)</p>
</div></blockquote>
<p><strong>X</strong> : array-like, shape (n_samples, n_features)</p>
<blockquote>
<div><p>Training vector, where n_samples in the number of samples
and n_features is the number of features.</p>
</div></blockquote>
<p><strong>If self.input_type is &#8216;distance&#8217;:</strong></p>
<p><strong>X</strong> : array-like, shape (n_samples, n_samples),</p>
<blockquote>
<div><p>Interpret X as precomputed distance or adjacency graph
computed from samples.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : object</p>
<blockquote class="last">
<div><p>Returns the instance itself.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="megaman.embedding.locally_linear.barycenter_graph">
<code class="descclassname">megaman.embedding.locally_linear.</code><code class="descname">barycenter_graph</code><span class="sig-paren">(</span><em>distance_matrix</em>, <em>X</em>, <em>reg=0.001</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/locally_linear.html#barycenter_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.locally_linear.barycenter_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the barycenter weighted graph for points in X</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>distance_matrix: sparse Ndarray, (N_obs, N_obs) pairwise distance matrix.</strong></p>
<p><strong>X</strong> : Ndarray (N_obs, N_dim) observed data matrix.</p>
<p><strong>reg</strong> : float, optional</p>
<blockquote>
<div><p>Amount of regularization when solving the least-squares
problem. Only relevant if mode=&#8217;barycenter&#8217;. If None, use the
default.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : sparse matrix in CSR format, shape = [n_samples, n_samples]</p>
<blockquote class="last">
<div><p>W[i, j] is assigned the weight of edge that connects i to j.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="megaman.embedding.locally_linear.locally_linear_embedding">
<code class="descclassname">megaman.embedding.locally_linear.</code><code class="descname">locally_linear_embedding</code><span class="sig-paren">(</span><em>geom</em>, <em>n_components</em>, <em>reg=0.001</em>, <em>max_iter=100</em>, <em>eigen_solver='auto'</em>, <em>tol=1e-06</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/locally_linear.html#locally_linear_embedding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.locally_linear.locally_linear_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a Locally Linear Embedding analysis on the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>geom</strong> : a Geometry object from megaman.geometry.geometry</p>
<p><strong>n_components</strong> : integer</p>
<blockquote>
<div><p>number of coordinates for the manifold.</p>
</div></blockquote>
<p><strong>reg</strong> : float</p>
<blockquote>
<div><p>regularization constant, multiplies the trace of the local covariance
matrix of the distances.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>tol</strong> : float, optional</p>
<blockquote>
<div><p>Tolerance for &#8216;arpack&#8217; method
Not used if eigen_solver==&#8217;dense&#8217;.</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>maximum number of iterations for the arpack solver.</p>
</div></blockquote>
<p><strong>random_state</strong> : numpy.RandomState or int, optional</p>
<blockquote>
<div><p>The generator or seed used to determine the starting vector for arpack
iterations.  Defaults to numpy.random.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Y</strong> : array-like, shape [n_samples, n_components]</p>
<blockquote>
<div><p>Embedding vectors.</p>
</div></blockquote>
<p><strong>squared_error</strong> : float</p>
<blockquote class="last">
<div><p>Reconstruction error for the embedding vectors. Equivalent to
<code class="docutils literal"><span class="pre">norm(Y</span> <span class="pre">-</span> <span class="pre">W</span> <span class="pre">Y,</span> <span class="pre">'fro')**2</span></code>, where W are the reconstruction weights.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R2]</a></td><td>Roweis, S. &amp; Saul, L. Nonlinear dimensionality reduction
by locally linear embedding.  Science 290:2323 (2000).</td></tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-megaman.embedding.ltsa"></span><p>Local Tangent Space Alignment</p>
<dl class="class">
<dt id="megaman.embedding.ltsa.LTSA">
<em class="property">class </em><code class="descclassname">megaman.embedding.ltsa.</code><code class="descname">LTSA</code><span class="sig-paren">(</span><em>n_components=2</em>, <em>eigen_solver='auto'</em>, <em>random_state=None</em>, <em>tol=1e-06</em>, <em>max_iter=100</em>, <em>geom=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/ltsa.html#LTSA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.ltsa.LTSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Local Tangent Space Alignment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_components</strong> : integer</p>
<blockquote>
<div><p>number of coordinates for the manifold.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>tol</strong> : float, optional</p>
<blockquote>
<div><p>Tolerance for &#8216;arpack&#8217; method
Not used if eigen_solver==&#8217;dense&#8217;.</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>maximum number of iterations for the arpack solver.</p>
</div></blockquote>
<p><strong>random_state</strong> : numpy.RandomState or int, optional</p>
<blockquote>
<div><p>The generator or seed used to determine the starting vector for arpack
iterations.  Defaults to numpy.random.</p>
</div></blockquote>
<p><strong>neighborhood_radius</strong> : scalar, passed to distance_matrix. Value such that all</p>
<blockquote>
<div><p>distances beyond neighborhood_radius are considered infinite.</p>
</div></blockquote>
<p><strong>affinity_radius</strong> : scalar, passed to affinity_matrix. &#8216;bandwidth&#8217; parameter</p>
<blockquote>
<div><p>used in Guassian kernel for affinity matrix</p>
</div></blockquote>
<p><strong>distance_method</strong> : string, one of &#8216;auto&#8217;, &#8216;brute&#8217;, &#8216;cython&#8217;, &#8216;pyflann&#8217;, &#8216;cyflann&#8217;.</p>
<blockquote>
<div><p>method for computing pairwise radius neighbors graph.</p>
</div></blockquote>
<p><strong>input_type</strong> : string, one of: &#8216;data&#8217;, &#8216;distance&#8217;, &#8216;affinity&#8217;.</p>
<blockquote>
<div><p>The values of input data X.</p>
</div></blockquote>
<p><strong>path_to_flann</strong> : string. full file path location of FLANN if not installed to</p>
<blockquote>
<div><p>root or to set FLANN_ROOT set to path location. Used for importing pyflann
from a different location.</p>
</div></blockquote>
<p><strong>geom</strong> : either a Geometry object from megaman.geometry or a dictionary</p>
<blockquote class="last">
<div><p>containing (some or all) geometry parameters: adjacency_method,
adjacency_kwds, affinity_method, affinity_kwds, laplacian_method,
laplacian_kwds as keys.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Zhang, Z. &amp; Zha, H. Principal manifolds and nonlinear
dimensionality reduction via tangent space alignment.
Journal of Shanghai Univ.  8:406 (2004)</li>
</ul>
<dl class="method">
<dt id="megaman.embedding.ltsa.LTSA.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>input_type='data'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/ltsa.html#LTSA.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.ltsa.LTSA.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model from data in X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input_type</strong> : string, one of: &#8216;data&#8217;, &#8216;distance&#8217;.</p>
<blockquote>
<div><p>The values of input data X. (default = &#8216;data&#8217;)</p>
</div></blockquote>
<p><strong>X</strong> : array-like, shape (n_samples, n_features)</p>
<blockquote>
<div><p>Training vector, where n_samples in the number of samples
and n_features is the number of features.</p>
</div></blockquote>
<p><strong>If self.input_type is &#8216;distance&#8217;, or &#8216;affinity&#8217;:</strong></p>
<p><strong>X</strong> : array-like, shape (n_samples, n_samples),</p>
<blockquote>
<div><p>Interpret X as precomputed distance or adjacency graph
computed from samples.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : object</p>
<blockquote class="last">
<div><p>Returns the instance itself.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="megaman.embedding.ltsa.ltsa">
<code class="descclassname">megaman.embedding.ltsa.</code><code class="descname">ltsa</code><span class="sig-paren">(</span><em>geom</em>, <em>n_components</em>, <em>eigen_solver='auto'</em>, <em>tol=1e-06</em>, <em>max_iter=100</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/embedding/ltsa.html#ltsa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.embedding.ltsa.ltsa" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a Local Tangent Space Alignment analysis on the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>geom</strong> : a Geometry object from megaman.geometry.geometry</p>
<p><strong>n_components</strong> : integer</p>
<blockquote>
<div><p>number of coordinates for the manifold.</p>
</div></blockquote>
<p><strong>eigen_solver</strong> : {&#8216;auto&#8217;, &#8216;dense&#8217;, &#8216;arpack&#8217;, &#8216;lobpcg&#8217;, or &#8216;amg&#8217;}</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;auto&#8217; :</dt>
<dd><p class="first last">algorithm will attempt to choose the best method for input data</p>
</dd>
<dt>&#8216;dense&#8217; :</dt>
<dd><p class="first last">use standard dense matrix operations for the eigenvalue decomposition.
For this method, M must be an array or matrix type.  This method should be avoided for large problems.</p>
</dd>
<dt>&#8216;arpack&#8217; :</dt>
<dd><p class="first last">use arnoldi iteration in shift-invert mode. For this method,
M may be a dense matrix, sparse matrix, or general linear operator.
Warning: ARPACK can be unstable for some problems.  It is best to
try several random seeds in order to check results.</p>
</dd>
<dt>&#8216;lobpcg&#8217; :</dt>
<dd><p class="first last">Locally Optimal Block Preconditioned Conjugate Gradient Method.
A preconditioned eigensolver for large symmetric positive definite
(SPD) generalized eigenproblems.</p>
</dd>
<dt>&#8216;amg&#8217; :</dt>
<dd><p class="first last">AMG requires pyamg to be installed. It can be faster on very large,
sparse problems, but may also lead to instabilities.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>tol</strong> : float, optional</p>
<blockquote>
<div><p>Tolerance for &#8216;arpack&#8217; method
Not used if eigen_solver==&#8217;dense&#8217;.</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>maximum number of iterations for the arpack solver.</p>
</div></blockquote>
<p><strong>random_state</strong> : numpy.RandomState or int, optional</p>
<blockquote>
<div><p>The generator or seed used to determine the starting vector for arpack
iterations.  Defaults to numpy.random.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>embedding</strong> : array-like, shape [n_samples, n_components]</p>
<blockquote>
<div><p>Embedding vectors.</p>
</div></blockquote>
<p><strong>squared_error</strong> : float</p>
<blockquote class="last">
<div><p>Reconstruction error for the embedding vectors. Equivalent to
<code class="docutils literal"><span class="pre">norm(Y</span> <span class="pre">-</span> <span class="pre">W</span> <span class="pre">Y,</span> <span class="pre">'fro')**2</span></code>, where W are the reconstruction weights.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Zhang, Z. &amp; Zha, H. Principal manifolds and nonlinear
dimensionality reduction via tangent space alignment.
Journal of Shanghai Univ.  8:406 (2004)</li>
</ul>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tools for Embedding (<code class="docutils literal"><span class="pre">megaman.embedding</span></code>)</a><ul>
      <li>Previous: <a href="spectral_embedding.html" title="previous chapter">Spectral Embedding</a></li>
      <li>Next: <a href="../utils/index.html" title="next chapter">Utility tools for megaman (<code class="docutils literal"><span class="pre">megaman.utils</span></code>)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/embedding/API.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, James McQueen, Marina Meila.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="../_sources/embedding/API.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>