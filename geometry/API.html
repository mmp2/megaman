<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Documentation &mdash; megaman 0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="megaman 0.2 documentation" href="../index.html" />
    <link rel="up" title="Tools for Geometric Analysis (megaman.geometry)" href="index.html" />
    <link rel="next" title="Tools for Embedding (megaman.embedding)" href="../embedding/index.html" />
    <link rel="prev" title="Geometry" href="geometry.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="geometry-api"></span><div class="section" id="module-megaman.geometry.geometry">
<span id="api-documentation"></span><h1>API Documentation<a class="headerlink" href="#module-megaman.geometry.geometry" title="Permalink to this headline">¶</a></h1>
<p>Scalable Manifold learning utilities and algorithms.</p>
<p>Graphs are represented with their weighted adjacency matrices, preferably using
sparse matrices.</p>
<div class="section" id="a-note-on-symmetrization-and-internal-sparse-representations">
<h2>A note on symmetrization and internal sparse representations<a class="headerlink" href="#a-note-on-symmetrization-and-internal-sparse-representations" title="Permalink to this headline">¶</a></h2>
<p>For performance, this code uses the FLANN library to compute
approximate neighborhoods efficiently. This means that (1) the
adjacency matrix produced is NOT GUARANTEED to be symmetric and
(2) compute_adjacency_matrix returns a sparse matrix called
adjacency_matrix. adjacency_matrix has 0.0 on the diagonal,
as it should. Implicitly, the missing entries are infinity not
0 for this matrix. But (1) and (2) mean that if one tries to
symmetrize adjacency_matrix, the scipy.sparse code eliminates
the 0.0 entries from adjacency_matrix hence in the affinity
matrix we explicitly set the diagonal to 1.0 for sparse matrices.</p>
<dl class="docutils">
<dt>We adopted the following convention:</dt>
<dd><ul class="first last simple">
<li>adjacency_matrix will NOT BE GUARANTEED symmetric</li>
<li>affinity_matrix will perform a symmetrization by default</li>
<li>laplacian performs symmetrization 
only if symmetrize_input=True (the default setting), and DOES NOT check symmetry</li>
<li>these conventions are the same for dense matrices, for consistency</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="megaman.geometry.geometry.Geometry">
<em class="property">class </em><code class="descclassname">megaman.geometry.geometry.</code><code class="descname">Geometry</code><span class="sig-paren">(</span><em>adjacency_method='auto'</em>, <em>adjacency_kwds=None</em>, <em>affinity_method='auto'</em>, <em>affinity_kwds=None</em>, <em>laplacian_method='auto'</em>, <em>laplacian_kwds=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>The Geometry class stores the data, distance, affinity and laplacian
matrices used by the various embedding methods and is the primary
object passed to embedding functions.</p>
<p>The Geometry class contains functions to compute the aforementioned
matrices and allows for re-computation whenever necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>adjacency_method</strong> : string {&#8216;auto&#8217;, &#8216;brute&#8217;, &#8216;pyflann&#8217;, &#8216;cyflann&#8217;}</p>
<blockquote>
<div><p>method for computing pairwise radius neighbors graph.</p>
</div></blockquote>
<p><strong>adjacency_kwds</strong> : dict</p>
<blockquote>
<div><p>dictionary containing keyword arguments for adjacency matrix.
see distance.py docmuentation for arguments for each method.
If new kwargs are passed to compute_adjacency_matrix then this
dictionary will be updated.</p>
</div></blockquote>
<p><strong>affinity_method</strong> : string {&#8216;auto&#8217;, &#8216;gaussian&#8217;}</p>
<blockquote>
<div><p>method of computing affinity matrix</p>
</div></blockquote>
<p><strong>affinity_kwds</strong> : dict</p>
<blockquote>
<div><p>dictionary containing keyword arguments for affinity matrix.
see affinity.py docmuentation for arguments for each method.
If new kwargs are passed to compute_affinity_matrix then this
dictionary will be updated.</p>
</div></blockquote>
<p><strong>laplacian_method</strong> : string,</p>
<blockquote>
<div><p>type of laplacian to be computed. Possibilities are
{&#8216;symmetricnormalized&#8217;, &#8216;geometric&#8217;, &#8216;renormalized&#8217;,
&#8216;unnormalized&#8217;, &#8216;randomwalk&#8217;} see laplacian.py for more information.</p>
</div></blockquote>
<p><strong>laplacian_kwds</strong> : dict</p>
<blockquote>
<div><p>dictionary containing keyword arguments for Laplacian matrix.
see laplacian.py docmuentation for arguments for each method.
If new kwargs are passed to compute_laplacian_matrix then this
dictionary will be updated.</p>
</div></blockquote>
<p><strong>**kwargs :</strong></p>
<blockquote class="last">
<div><p>additional arguments will be parsed and used to override values in
the above dictionaries. For example:
- <cite>affinity_radius</cite> will override <cite>affinity_kwds[&#8216;radius&#8217;]</cite>
- <cite>adjacency_n_neighbors</cite> will override <cite>adjacency_kwds[&#8216;n_neighbors&#8217;]</cite>
etc.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.compute_adjacency_matrix">
<code class="descname">compute_adjacency_matrix</code><span class="sig-paren">(</span><em>copy=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.compute_adjacency_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.compute_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will compute the adjacency matrix.
In order to acquire the existing adjacency matrix use
self.adjacency_matrix as comptute_adjacency_matrix() will re-compute
the adjacency matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>copy</strong> : boolean, whether to return a copied version of the adjacency matrix</p>
<p><strong>**kwargs</strong> : see distance.py docmuentation for arguments for each method.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self.adjacency_matrix</strong> : sparse matrix (N_obs, N_obs)</p>
<blockquote class="last">
<div><p>Non explicit 0.0 values should be considered not connected.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.compute_affinity_matrix">
<code class="descname">compute_affinity_matrix</code><span class="sig-paren">(</span><em>copy=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.compute_affinity_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.compute_affinity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will compute the affinity matrix. In order to
acquire the existing affinity matrix use self.affinity_matrix as
comptute_affinity_matrix() will re-compute the affinity matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>copy</strong> : boolean</p>
<blockquote>
<div><p>whether to return a copied version of the affinity matrix</p>
</div></blockquote>
<p><strong>**kwargs :</strong></p>
<blockquote>
<div><p>see affinity.py docmuentation for arguments for each method.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self.affinity_matrix</strong> : sparse matrix (N_obs, N_obs)</p>
<blockquote class="last">
<div><p>contains the pairwise affinity values using the Guassian kernel
and bandwidth equal to the affinity_radius</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.compute_laplacian_matrix">
<code class="descname">compute_laplacian_matrix</code><span class="sig-paren">(</span><em>copy=True</em>, <em>return_lapsym=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.compute_laplacian_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.compute_laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Note: this function will compute the laplacian matrix. In order to acquire</dt>
<dd>the existing laplacian matrix use self.laplacian_matrix as
comptute_laplacian_matrix() will re-compute the laplacian matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>copy</strong> : boolean, whether to return copied version of the self.laplacian_matrix</p>
<p><strong>return_lapsym</strong> : boolean, if True returns additionally the symmetrized version of</p>
<blockquote>
<div><p>the requested laplacian and the re-normalization weights.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : see laplacian.py docmuentation for arguments for each method.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self.laplacian_matrix</strong> : sparse matrix (N_obs, N_obs).</p>
<blockquote>
<div><p>The requested laplacian.</p>
</div></blockquote>
<p><strong>self.laplacian_symmetric</strong> : sparse matrix (N_obs, N_obs)</p>
<blockquote>
<div><p>The symmetric laplacian.</p>
</div></blockquote>
<p><strong>self.laplacian_weights</strong> : ndarray (N_obs,)</p>
<blockquote class="last">
<div><p>The renormalization weights used to make
laplacian_matrix from laplacian_symmetric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.set_adjacency_matrix">
<code class="descname">set_adjacency_matrix</code><span class="sig-paren">(</span><em>adjacency_mat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.set_adjacency_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.set_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>adjacency_mat</strong> : sparse matrix (N_obs, N_obs)</p>
<blockquote class="last">
<div><p>The adjacency matrix to input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.set_affinity_matrix">
<code class="descname">set_affinity_matrix</code><span class="sig-paren">(</span><em>affinity_mat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.set_affinity_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.set_affinity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>affinity_mat</strong> : sparse matrix (N_obs, N_obs).</p>
<blockquote class="last">
<div><p>The adjacency matrix to input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.set_data_matrix">
<code class="descname">set_data_matrix</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.set_data_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.set_data_matrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : ndarray (N_obs, N_features)</p>
<blockquote class="last">
<div><p>The original data set to input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.set_laplacian_matrix">
<code class="descname">set_laplacian_matrix</code><span class="sig-paren">(</span><em>laplacian_mat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.set_laplacian_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.set_laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>laplacian_mat</strong> : sparse matrix (N_obs, N_obs).</p>
<blockquote class="last">
<div><p>The Laplacian matrix to input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.set_matrix">
<code class="descname">set_matrix</code><span class="sig-paren">(</span><em>X</em>, <em>input_type</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.set_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.set_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the data matrix given the (string) input_type</p>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.geometry.Geometry.set_radius">
<code class="descname">set_radius</code><span class="sig-paren">(</span><em>radius</em>, <em>override=True</em>, <em>X=None</em>, <em>n_components=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/geometry.html#Geometry.set_radius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.geometry.Geometry.set_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the radius for the adjacency and affinity computation</p>
<p>By default, this will override keyword arguments provided on
initialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radius</strong> : float</p>
<blockquote>
<div><p>radius to set for adjacency and affinity.</p>
</div></blockquote>
<p><strong>override</strong> : bool (default: True)</p>
<blockquote>
<div><p>if False, then only set radius if not already defined in
<cite>adjacency_args</cite> and <cite>affinity_args</cite>.</p>
</div></blockquote>
<p><strong>X</strong> : ndarray or sparse (optional)</p>
<blockquote>
<div><p>if provided, estimate a suitable radius from this data.</p>
</div></blockquote>
<p><strong>n_components</strong> : int (default=2)</p>
<blockquote class="last">
<div><p>the number of components to use when estimating the radius</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-megaman.geometry.rmetric"></span><p>Riemannian Metric learning utilities and algorithms.</p>
<p>To use the &#8220;geometric&#8221; Laplacian from geometry.py for statistically
consistent results.</p>
<dl class="class">
<dt id="megaman.geometry.rmetric.RiemannMetric">
<em class="property">class </em><code class="descclassname">megaman.geometry.rmetric.</code><code class="descname">RiemannMetric</code><span class="sig-paren">(</span><em>Y</em>, <em>laplacian</em>, <em>n_dim=None</em>, <em>mode_inv='svd'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/rmetric.html#RiemannMetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.rmetric.RiemannMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>RiemannMetric computes and stores the Riemannian metric and its dual
associated with an embedding Y. The Riemannian metric is currently denoted
by G, its dual by H, and the Laplacian by L. G at each point is the
matrix inverse of H.</p>
<p>For performance, the following choices have been made:
* the class makes no defensive copies of L, Y
* no defensive copies of the array attributes H, G, Hvv, ....
* G is computed on request only
In the future, this class will be extended to compute H only once,
for mdimY dimensions, but to store multiple G&#8217;s, with different dimensions.</p>
<p>In the near future plans is also a &#8220;lazy&#8221; implementation, which will
compute G (and maybe even H) only at the requested points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Y</strong> : embedding coordinates, shape = (n, mdimY)</p>
<p><strong>laplacian</strong> : estimated laplacian from data  shape = (n, n)</p>
<p><strong>n_dim</strong> : the manifold domension</p>
<p><strong>mod_inv</strong> : if mode_inv = svd, also returns Hvv, Hsvals,</p>
<blockquote>
<div><p>Gsvals the (transposed) eigenvectors of
H and the singular values of H and G</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mdimG</strong> : dimension of G, H</p>
<p><strong>mdimY</strong> : dimension of Y</p>
<p><strong>H</strong> : dual Riemann metric, shape = (n, mdimY, mdimY)</p>
<p><strong>G</strong> : Riemann metric, shape = (n, mdimG, mdimG)</p>
<p><strong>Hvv</strong> : (transposed) singular vectors of H, shape = (n, mdimY, mdimY)</p>
<p><strong>Hsvals</strong> : singular values of H, shape = (n, mdimY)</p>
<p><strong>Gsvals</strong> : singular values of G, shape = (n, mdimG)</p>
<p class="last"><strong>detG</strong> : determinants of G, shape = (n,1)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>H is always computed at full dimension self.mdimY
G is computed at mdimG (some contradictions persist here)</p>
<p class="rubric">References</p>
<p>&#8220;Non-linear dimensionality reduction: Riemannian metric estimation and
the problem of geometric discovery&#8221;,
Dominique Perraul-Joncas, Marina Meila, arXiv:1305.7255</p>
<dl class="method">
<dt id="megaman.geometry.rmetric.RiemannMetric.get_dual_rmetric">
<code class="descname">get_dual_rmetric</code><span class="sig-paren">(</span><em>invert_h=False</em>, <em>mode_inv='svd'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/rmetric.html#RiemannMetric.get_dual_rmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.rmetric.RiemannMetric.get_dual_rmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the dual Riemannian Metric
This is not satisfactory, because if mdimG&lt;mdimY the shape of H
will not be the same as the shape of G. TODO(maybe): return a (copied)
smaller H with only the rows and columns in G.</p>
</dd></dl>

<dl class="method">
<dt id="megaman.geometry.rmetric.RiemannMetric.get_rmetric">
<code class="descname">get_rmetric</code><span class="sig-paren">(</span><em>mode_inv='svd'</em>, <em>return_svd=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/rmetric.html#RiemannMetric.get_rmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.rmetric.RiemannMetric.get_rmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Reimannian Metric</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="megaman.geometry.rmetric.compute_G_from_H">
<code class="descclassname">megaman.geometry.rmetric.</code><code class="descname">compute_G_from_H</code><span class="sig-paren">(</span><em>H</em>, <em>mdimG=None</em>, <em>mode_inv='svd'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/rmetric.html#compute_G_from_H"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.rmetric.compute_G_from_H" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : the inverse R. Metric</p>
<p><strong>if mode_inv == &#8216;svd&#8217;:</strong></p>
<blockquote>
<div><p>also returns Hvv, Hsvals, Gsvals the (transposed) eigenvectors of
H and the singular values of H and G</p>
</div></blockquote>
<p><strong>if mdimG &lt; H.shape[2]:</strong></p>
<blockquote class="last">
<div><p>G.shape = [ n_samples, mdimG, mdimG ] with n_samples = H.shape[0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>currently Hvv, Hsvals are n_dim = H.shape[2], and Gsvals, G are mdimG
(This contradicts the documentation of riemann_metric which states
that riemann_metric and h_dual_metric have the same dimensions)</p>
<p>See the notes in RiemannMetric</p>
</dd></dl>

<dl class="function">
<dt id="megaman.geometry.rmetric.riemann_metric">
<code class="descclassname">megaman.geometry.rmetric.</code><code class="descname">riemann_metric</code><span class="sig-paren">(</span><em>Y</em>, <em>laplacian=None</em>, <em>n_dim=None</em>, <em>invert_h=False</em>, <em>mode_inv='svd'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/rmetric.html#riemann_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.rmetric.riemann_metric" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Y: array-like, shape = (n_samples, mdimY )</strong></p>
<blockquote>
<div><p>The embedding coordinates of the points</p>
</div></blockquote>
<p><strong>laplacian: array-like, shape = (n_samples, n_samples)</strong></p>
<blockquote>
<div><p>The Laplacian of the data. It is recommended to use the &#8220;geometric&#8221;
Laplacian (default) option from geometry.graph_laplacian()</p>
</div></blockquote>
<p><strong>n_dim</strong> : integer, optional</p>
<blockquote>
<div><p>Use only the first n_dim &lt;= mdimY dimensions.All dimensions
n_dim:mdimY are ignored.</p>
</div></blockquote>
<p><strong>invert_h: boolean, optional</strong></p>
<blockquote>
<div><p>if False, only the &#8220;dual Riemannian metric&#8221; is computed
if True, the dual metric matrices are inverted to obtain the
Riemannian metric G.</p>
</div></blockquote>
<p><strong>mode_inv: string, optional</strong></p>
<blockquote>
<div><dl class="docutils">
<dt>How to compute the inverses of h_dual_metric, if invert_h</dt>
<dd><p class="first last">&#8220;inv&#8221;, use numpy.inv()
&#8220;svd&#8221; (default), use numpy.linalg.svd(), then invert the eigenvalues
(possibly a more numerically stable method with H is symmetric and
ill conditioned)</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h_dual_metric</strong> : array, shape=(n_samples, n_dim, n_dim)</p>
<p>Optionally :</p>
<p><strong>g_riemann_metric</strong> : array, shape=(n_samples, n_dim, n_dim )</p>
<p><strong>Hvv</strong> : singular vectors of H, transposed, shape = ( n_samples, n_dim, n_dim )</p>
<p><strong>Hsvals</strong> : singular values of H, shape = ( n_samples, n_dim )</p>
<p class="last"><strong>Gsvals</strong> : singular values of G, shape = ( n_samples, n_dim )</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p class="rubric">References</p>
<p>&#8220;Non-linear dimensionality reduction: Riemannian metric estimation and
the problem of geometric discovery&#8221;,
Dominique Perraul-Joncas, Marina Meila, arXiv:1305.7255</p>
</dd></dl>

<dl class="function">
<dt id="megaman.geometry.rmetric.riemann_metric_lazy">
<code class="descclassname">megaman.geometry.rmetric.</code><code class="descname">riemann_metric_lazy</code><span class="sig-paren">(</span><em>Y</em>, <em>sample</em>, <em>laplacian</em>, <em>n_dim</em>, <em>invert_h=False</em>, <em>mode_inv='svd'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/megaman/geometry/rmetric.html#riemann_metric_lazy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#megaman.geometry.rmetric.riemann_metric_lazy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Y: array-like, shape = (n_samples, mdimY )</strong></p>
<blockquote>
<div><p>The embedding coordinates of the points</p>
</div></blockquote>
<p><strong>sample</strong> : array-like, shape (n_samples)</p>
<blockquote>
<div><p>array of indices over which to calculate the riemannian metric.</p>
</div></blockquote>
<p><strong>laplacian: array-like, shape = (n_samples, n_samples)</strong></p>
<blockquote>
<div><p>The Laplacian of the data. It is recommended to use the &#8220;geometric&#8221;
Laplacian (default) option from geometry.graph_laplacian()</p>
</div></blockquote>
<p><strong>n_dim</strong> : integer, optional</p>
<blockquote>
<div><p>Use only the first n_dim &lt;= mdimY dimensions.All dimensions
n_dim:mdimY are ignored.</p>
</div></blockquote>
<p><strong>invert_h: boolean, optional</strong></p>
<blockquote>
<div><p>if False, only the &#8220;dual Riemannian metric&#8221; is computed
if True, the dual metric matrices are inverted to obtain the
Riemannian metric G.</p>
</div></blockquote>
<p><strong>mode_inv: string, optional</strong></p>
<blockquote>
<div><dl class="docutils">
<dt>How to compute the inverses of h_dual_metric, if invert_h</dt>
<dd><p class="first last">&#8220;inv&#8221;, use numpy.inv()
&#8220;svd&#8221; (default), use numpy.linalg.svd(), then invert the eigenvalues
(possibly a more numerically stable method with H is symmetric and
ill conditioned)</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h_dual_metric</strong> : array, shape=(n_samples, n_dim, n_dim)</p>
<p>Optionally :</p>
<p><strong>g_riemann_metric</strong> : array, shape=(n_samples, n_dim, n_dim )</p>
<p><strong>Hvv</strong> : singular vectors of H, transposed, shape = ( n_samples, n_dim, n_dim )</p>
<p><strong>Hsvals</strong> : singular values of H, shape = ( n_samples, n_dim )</p>
<p class="last"><strong>Gsvals</strong> : singular values of G, shape = ( n_samples, n_dim )</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p class="rubric">References</p>
<p>&#8220;Non-linear dimensionality reduction: Riemannian metric estimation and
the problem of geometric discovery&#8221;,
Dominique Perraul-Joncas, Marina Meila, arXiv:1305.7255</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API Documentation</a><ul>
<li><a class="reference internal" href="#a-note-on-symmetrization-and-internal-sparse-representations">A note on symmetrization and internal sparse representations</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tools for Geometric Analysis (<code class="docutils literal"><span class="pre">megaman.geometry</span></code>)</a><ul>
      <li>Previous: <a href="geometry.html" title="previous chapter">Geometry</a></li>
      <li>Next: <a href="../embedding/index.html" title="next chapter">Tools for Embedding (<code class="docutils literal"><span class="pre">megaman.embedding</span></code>)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/geometry/API.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, James McQueen, Marina Meila.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="../_sources/geometry/API.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>